# 564. Find the Closest Palindrome

This problem involved about, given a string n representing an integer, return the closest integer (not including itself), which is a palindrome. If there is a tie, return the smaller one.

## Problem description

For better problem description, please visit [LeetCode Page](https://leetcode.com/problems/find-the-closest-palindrome/description/)

**Approach :**<br/>

1. `Palindromes generated by the first half of `n``:

    - Construct a palindrome by mirroring the first half of `n`.
    - Also consider the cases where the first half is incremented or decremented by 1 to handle edge cases (like the middle digit carrying over).

2. `Edge cases`:
    - Consider numbers that are one order of magnitude smaller or larger than `n`, specifically `10^L - 1` and `10^L + 1`, where `L` is the length of `n`. These represent the smallest and largest palindromes possible with `L` digits.

#### Detailed Steps

1. `Extract the first half of the number`:

    - If `n` has an even number of digits, take the first `L/2` digits.
    - If `n` has an odd number of digits, take the first `L/2 + 1` digits.

2. `Generate Palindrome Candidates`:

    - Generate a palindrome using the first half as is.
    - Generate two more palindromes by incrementing and decrementing the first half by 1.
    - Include `10^L - 1` and `10^L + 1` as potential candidates.

3. `Compare Candidates`:
    - For each candidate, calculate the absolute difference with `n`.
    - Return the candidate with the smallest difference. In case of a tie, return the smaller candidate.

**Complexity Analysis :**<br/>

-   Time-Complexity: `O(n)` - The time complexity is linear with respect to the length `n` of the input number n. This is because we only generate a constant number of palindrome candidates and each operation (string slicing, conversion, comparison) depends on `n`.

-   Space-Complexity: `O(n)` - We store the 5 possible candidates in the `possibilities` array.